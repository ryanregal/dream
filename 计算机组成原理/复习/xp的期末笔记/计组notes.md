# 0 计算机组成原理目录



[TOC]



# 1 概述

<img src="D:\XPfile\学习资料\年级分类\大二下\计算机组成原理\pic\图片2.png" alt="图片2" style="zoom:67%;" />

### 1.1 计算机发展阶段

1. 电子管
2. 晶体管
3. 集成电路
4. 超大规模集成电路：出现微处理器CPU、个人计算机PC、微型计算机

目前发展趋势：更微型-多用途；更巨型-超高速

#### 摩尔定律



### 1.2 计算机系统组成



#### 冯诺依曼结构计算机

- 计算机系统中 软硬件在逻辑上等效


- 特点：


1.  计算机由运算器、控制器、存储器、输入 输出设备构成
1. 程序的功能都通过CPU执行指令完成。
3.  **指令与数据以同等地位存于存储器，可按地址寻访**
   - 取指令阶段取出的是指令，执行阶段访存取出的数据。
   - 指令按地址访问，数据由指令的地址码给出，并且除立即数寻址外，指令都无法直接给出数据。

4.  指令与数据可用二进制表示
5.  指令由操作码、地址码组成
6.  首次提出**存储程序、程序控制**概念
   - 将解题步骤编程程序，将程序与运行程序时需要的数据以二进制代码形式放进存储器，再由控制器逐条取出指令顺序执行

7.  **以运算器为中心**（IO设备与存储器的数据传送通过运算器完成）



- 冯诺依曼机的基本工作方式：控制流驱动方式

- 按照存储程序原理，计算机应具有：数据传送、存储、处理以及操作控制、操作判断功能



- 现代计算机：以存储器为中心


- CPU = 运算器 + 控制器




### 1.3 计算机系统层次结构



- 1~3 ：硬件层；4~6 ：软件层  4层面向机器   56面向应用

- **高级语言层**：面向用户的抽象层次
- **汇编语言层**：为用户提供基于助记符表示的汇编语言编程，此层与机器结构直接相关
- **操作系统**：用于对计算机系统硬件软件资源进行统一调度和管理，提高计算机使用效率 方便用户使用
- **指令集架构层**（传统机器层/ISA层）：机器语言编程实现对硬件的控制；软硬件间的界面和纽带
- **微代码层**：实际的机器层，微指令编程 编写的微程序硬件直接执行（只有微程序设计的计算机系统才有这一层）
- **硬件逻辑层**：最底层硬件系统，逻辑门、触发器等逻辑电路构成 布尔代数设计



- 编译、汇编、解释程序 统称为 翻译程序
- 汇编程序
  - 将汇编代码转换为目标代码

- 编译程序（C、C++）
  - 将**高级语言编写的源程序**全部语句一次性翻译成**机器语言程序（目标代码文件）** 而后再执行机器语言程序 
  - 只需翻译一次



- 解释程序（JavaScript、Python、Shell）

  - 将源程序的一条语句翻译成机器语句并立即执行 再翻译下一条语句
  - 每次执行都要翻译




### 1.4 计算机的性能指标

#### 存储器的性能指标

- MAR位数
  - 存储单元最多有多少个；
- MDR位数
  - 存储字长（每个存储单元的大小）

1. **字长**：CPU一次处理的数据位数，一般与计算及内部的寄存器、运算器、数据总线的位宽相等

   - 字长对计算机性能的影响：

     字长越长 计算精确度越高、定点数表示范围和浮点数范围、精度越高

2. **总容量**：主存能存储的最大信息量 = 存储单元个数 × 存储字长（bit）

   e.g. MAR32位 MDR8位：总容量 = 2^32^ * 8 bit = 4GB

   - 增加主存容量 可减少程序运行期间访问辅存的次数 提高程序执行速度、计算机性能
   - 单位：KB MB GB TB PB

3. **CPU主频**（Hz）：CPU内数字脉冲信号震荡的频率

   - 电脑型号中的3.6GHz 每秒钟有3.6G个脉冲信号

4. **CPU时钟周期**（ns、μs）：每个脉冲信号的时间

   - 是主频的倒数 1GHz = 1ns

   - 时钟周期：计算机中最小最基本的时间单位

5. **CPI**：执行<u>一条指令</u>所需要的时钟周期数 = m时钟周期数 / IC总指令数

   - 计算方法：平均CPI = ∑ CPI~i~ * IC出现频率或所占比例

   - 不同指令 CPI不同；相同指令 CPI也会变化

6. IPC：CPI倒数

7. **CPU时间**：执行整个程序的时间 = CPU时钟周期数 / 主频 = （指令条数 * CPI）/主频

   - 与以下因素有关：
     1. 主频f：f越大 程序执行速度越快；f取决于CPU实现技术和工艺
     2. CPI：CPI越小 执行速度越快；CPI取决于计算机实现技术和指令集结构
     3. IC：与指令系统设计和编译技术有关

8. IPS：每秒执行多少条指令 = 主频 / 平均CPI = IC / T~CPU~

   - 单位：KFLOPS(10^3^ 千)、MFLOPS(10^6^ 百万)、GFLOPS(10^9^ 十亿)、TFLOPS(10^12^ 万亿)
   - f越高 CPI越小，IPS越高

   > 主频：每秒多少个脉冲；时钟周期：一个脉冲多少秒；CPI：一条指令有多个脉冲，一条脉冲的时间

8. FLOPS：每秒执行多少次浮点运算



#### 系统整体性能指标

1. 数据通路带宽：数据总线一次所能并行传送信息的位数（CPU、主存储器、IO设备 这些硬件部件之间通过数据总线传输数据）
2. 吞吐量：指系统在单位时间内处理请求的数量，系统吞吐量主要取决于主存生存周期
3. 响应时间：用户向计算机发送一个请求 到系统对该请求作出响应并获得它所需要的结果的等待时间（包括CPU时间-运行一个程序所花费的时间、等待时间-磁盘访问 存储器访问 IO操作 操作系统开销时间）
4. 动态测试系统性能 -- 基准程序：测量计算机处理速度的程序



# 2 数据信息的表示



### 2.1 进制转换

1. 其他进制转十进制

   十进制转其他n进制：整数部分 --- 除以n，商再作为新的被除数，余数倒着取；小数部分 --- 小数部分不断乘以n，正着取整数部分

2. 二进制 --- 八/十六进制：以小数点为分界 向前向后每3/4个一组

   八/十六进制 --- 二进制：每一位数 对应3/4位二进制

### 2.2 BCD码

#### 8421码

8421码是有权码，低到高每一个二进制位对应 1 2 4 8

| 十进制数 | BCD码 | 十进制数 | BCD码 | 十进制数 | BCD码 |
| -------- | ----- | -------- | ----- | -------- | ----- |
| 0        | 0000  | 3        | 0011  | 6        | 0110  |
| 1        | 0001  | 4        | 0100  | 7        | 0111  |
| 2        | 0010  | 5        | 0101  | 8        | 1000  |
|          |       |          |       | 9        | 1001  |

BCD码直接相加 可得到十进制正确结果的二进制表示方法，但若结果在1010~10010之间 则需要转化成BCD形式 --- 加上0110（二进制的6）

#### 余3码

无权码

#### 2421码

规定：0~4 的2421码以0开头，5~9 以1开头

### 2.3 字符与字符串

#### ASCII码

8bit表示一个字符 最高位为0（0 ~ 127 共128个字符）

可印刷字符：32~126 其余为控制、通信字符

数字：48（0011 0000）~ 57（0011 1001）低四位对应BCD码 30H对应0

大写字母：65（0100 0001）~ 90（0101 1010）41H对应A

小写字母：97（0110 0001）~ 122（0111 1010）61H对应a

#### 汉字的表示与编码：国标码

- **区位码**（0 ~ 94）：94个区 每个区94个位置（即94×94个位子），起始字符“啊”对应编码1601,16---10H 01---01H
- **国标码**（32 ~ 125）：由于0 ~ 31是控制和通信字符 会在信息交换时候冲突 所以各加上32（即20H），30H 21H，但无法避免ASCII码区间
- **汉字内码**：若是要把汉字存到计算机里 还要加上80H，B0H A1H，保证高位为1 与ASCII区分

汉字的输入：**输入编码**（如拼音 五笔输入法）---输入软件---> 国标码 ---系统---> 汉字内码

汉字的输出：**汉字字形码**用于计算机输出汉字

#### 字符串存储

所有计算机中 多字节数据 如汉字 存放在连续的字节序列中，可采取大小端模式

小端模式：低对低 高对高（先存低字节 再存高字节）

大端模式：将数据的最高有效字节存放在低地址单元（先存高字节 再存低字节）



### 2.4 数据信息的校验

#### 奇偶校验

基本概念：

- 码字：若干位代码组成的一个字（如 A - 100；B - 001；C - 010；D - 111 都是码字，是2^3^=8种状态中取的四种合法状态 其他的就是非法码字 不表示ABCD任何一个数）

- 码距：两个码字逐位对比，具有不同的位的个数称为两个码字之间的距离（上述AC码字 有2个二进制位不同 距离为2），一种编码方案的各个合法码字之间的最小距离--码距

  上述编码中码距为2  说明任意码字之间有2个位不同 若一个位发生突变 则一定出现非法码字

  码距 == 1时 无检错能力；== 2时 有检错能力；>=3且设计合理 可以检错、纠错

奇校验码：在校验位设0或1，以保证整个校验码（有效信息位和校验位）中 1 的个数为奇数

偶校验码

若使用奇/偶校验码，则发生奇数个bit突变时，原奇/偶个1会变成偶/奇个1，与原定规则不符 --- 可判定错误；但若发生偶数个位突变就判别不出了 且奇数位错误也不知道错在哪

计算机实现偶校验：

1. 求偶校验位：各**信息位进行异或**运算（模2加） 得到的结果即偶校验位（异或：相同为0 相异为1）
2. 进行偶校验：**所有位进行异或** 结果为1则出错

#### 海明校验

奇偶校验只有1个校验位 对应对错两种状态

思路：基于偶校验码的拓展 将信息位分组进行偶校验 --- 多个校验位

海明码求解步骤：

1. 写出信息位所在的海明位号的二进制形式
2. 写出的二进制数字从高到低依次表示与哪个校验位有关（011 - 表示与P3无关 与P1P2有关）
3. 选出与每一个校验位有关的海明号对应的信息位数字 进行**异或**运算 得到各个校验位的值
4. 偶数个1 异或结果为0；奇数个1 结果为1
5. 进行纠错：每个检验码P及与之一组的信息位D进行**偶校验** 若未出错 偶校验结果应该是0

上述检错纠错能力：发生**1位**跳变 -- 可以纠错 指出哪一位错了；发生**2位**跳变 -- 只能检错 不知道错在哪

如上图 若P1P2都错了 发生2位跳变，则S3到S1为011 指向D3出错 但实际并不是D3一位跳变 而是P1P2都出错导致的

未解决上述问题，最高位加上**全校验位** 对整体进行偶校验



#### 循环冗余校验码

事先约定好除数，下图1101就是事先约定好的除数

信息位101001模2除1101的方法：最高位为1 就商1，剩下位数进行**异或**运算，最终**余数**就是校验位（比被除数少一位）余数位数==校验码位数

下图由于校验码必须是3位，所以模2除法后面有3个0（蓝色部分）

上面由于信息位太多 余数3位只能表示2^3^=8种状态 其中000表正确 只能7种错误状态 而发送位数有9位

下面信息位减少，可发现对于确定的多项式 出错位与余数对应（所以有纠错功能）

2^R^ - 1 >= K + R 时（即R位校验码可表示的错误状态大于等于总位数时）可纠一位错

实际应用中CRC一般只用于检错（几千个信息位加上几个校验位）

CRC检错能力的特点：

1. 可检测出所有奇数个错误
2. 可检测出所有双比特错误
3. 可检测出所有小于等于校验位长度的连续错误

出题：给出生成多项式确定除数，给出K个信息位，确定R位余数 最终与K信息位拼接得到最终CRC码



### 2.5 数据信息的表示⭐

int可以转double，不可以转float

#### 2.5.1 定点数的表示

⭐补码和移码对真值0表示唯一

⭐0的原码反码有两种

| 2^16^ | 2^15^ | 2^14^ | 2^13^ | 2^12^ | 2^11^ | 2^10^ | 2^9^ | 2^8^ | 2^7^ | 2^6^ |
| ----- | ----- | ----- | ----- | ----- | ----- | ----- | ---- | ---- | ---- | ---- |
| 65536 | 32768 | 16384 | 8192  | 4096  | 2048  | 1024  | 512  | 256  | 128  | 64   |

- ##### 有符号数的原反补移码


| （n+1)位       | 整数表示范围                                                 | 小数表示范围⭐（即再除2^n-1）                                 |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 原码和反码     | ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210120151218356.png#pic_center) | ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210120151620793.png#pic_center) |
| 补码           | ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210120151714872.png#pic_center)比原码反码多表示一个 因为 1,0000000 原本表示-0 规定表示-2^7^ | ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210120151736451.png#pic_center)规定 1.0000000 表示-1 |
| 移码(与补码同) | ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210120151819114.png#pic_center) | 移码全为0真值最小，移码全为1真值最大                         |

- 原码：符号位 + 尾数（真值的绝对值）


- 反码：原码符号位0-反码与原码相同；原码符号位1-**数值位**取反（符号位不取反）


- 补码：正数原反补相同；负数补码 = 对应正数的补码取反加1 或 负数原码数值位取反加1；

  - 负数原码 = 负数补码**数值位**取反加1

  - 由 x 的补码求 -x 的补码：连同符号位全部取反 末尾加1


- 移码：补码基础上 符号位取反


<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606185247908.png" alt="image-20220606185247908" style="zoom:67%;" />

- **补码的作用**：求 88-66 --- 原码相减01011000-01000010 转化为被减数原码加上-66补码01011000+10111110

- **移码的作用**：便于比较整数的大小



#### 2.5.2 浮点数的表示

<img src="file:///C:\Users\icebear\Documents\Tencent Files\1822327087\Image\C2C\8425DCD047544994D6116A2A02BF84A7.jpg" alt="img" style="zoom: 33%;" />

![image-20220606185321170](C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606185321170.png)

- **浮点数尾数的规格化**：规定尾数最高数值必须是一个有效位

  - 左规：算数左移1位 阶码减1


  - 右规：当浮点数运算结果尾数溢出时（双符号位为01或10）尾数算术右移1位 阶码加1


<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606185404063.png" alt="image-20220606185404063" style="zoom:67%;" />

- **规格化的原码尾数 最高位一定是1**；

- 规格化的补码 最高位是0-正数-尾数最高位必须是1，最高位是1-负数-尾数最高位必须是0




**E.g.** 某浮点数阶码为 0,110 ，尾数为 1.1110100,均用补码表示，如何规格化？

1. 负数浮点数补码最高位为1则规格化后尾数最高位必须为0，可通过算术左移
2. 负数补码算术左移，低位补0；算术右移，高位补1
3. 所以需要算术左移3位，最终规格化为 1.0100000 阶码加3

溢出：

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606185430059.png" alt="image-20220606185430059" style="zoom:80%;" />

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606185454187.png" alt="image-20220606185454187" style="zoom:80%;" />

- 对于非IEEE标准的移码表示的阶码：取值范围-全0到全1；


- IEEE中 8位全0阶码对应-127，全1对应-128




##### IEEE754

- 移码 = 补码符号位取反 = 真值 + 偏置值（一般偏置值 = 2^n-1^，n为包括符号位的位数）


- IEEE中规定 **偏置值为127**


<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606185530369.png" alt="image-20220606185530369" style="zoom:67%;" />

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606185554704.png" alt="image-20220606185554704" style="zoom:67%;" />

- 注意真值正常范围：当E表示的无符号整数在1~254时，-126 ~ 127；


- 因为-128对应255-阶码移码全1 和-127对应0-阶码移码全0 有特殊作用：


- 若要表示的绝对值比最小绝对值还要小，如 0.001×2^-126^：此时表示的数是非规格化小数，尾数部分为001 隐含最高位不是1而是0了、阶码虽然真值是-126 但转化为移码仍表示成全0

- 已知IEEE格式，求真值：真值为 (-1)^S^ * 1.M * 2^E-127^ 阶码真值 = 移码E - 偏置值127

  

**IEEE表示的范围**

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606185615404.png" alt="image-20220606185615404" style="zoom:67%;" />



# 3 数据的运算



### 3.1 移位运算

#### 原反补码的算术移位

符号位不变 仅对数值进行移位

|          | 原码                                                         | 反码                                                         | 补码                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **右移** | 高位补0 低位舍弃<br />舍弃的位== 0 相当于 ÷2<br />舍弃的位 ==1 就会丢失精度 | 正数的反码与原码相同                                         | 正数补码与原码相同                                           |
| **左移** | 低位补0 高位舍弃<br />舍弃的== 0 相当于×2<br />舍弃的== 1 则会严重误差 | 负数的反码：<br />右移：高位补1低位舍弃<br />左移：低位补1高位舍弃 | 负数的补码算术移位：<br />右移（同反码）：高位补1<br />左移（同原码）：低位补0 |

由于负数补码=反码+1，导致反码最右边的1会进位变成0 知道进位碰到第一个0

规律：负数补码中，最右边的1及右边同原码，最右边的1的左边同反码



逻辑移位

循环移位

1. 不带进位循环移位：可用于大小端的转换 即左或右移8位实现高低字节的转换
2. 带进位循环移位



### 3.2 加减运算及溢出判断

原码的加法运算（原码的减法运算可转化为加法运算

| 正+正                                  | 负+负                                  | 正+负 / 负+正                                   |
| -------------------------------------- | -------------------------------------- | ----------------------------------------------- |
| 绝对值相加<br />结果为正<br />可能溢出 | 绝对值相加<br />结果为负<br />可能溢出 | 绝对值大的-绝对值小的<br />结果符号同绝对值大的 |

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606172914943.png" alt="image-20220606172914943" style="zoom:80%;" />

**负数补码求原码**：① 补码数值位取反加1；② 负数补码最右边的1及其右边同原码，最右边的1的左边同反码 所以取反

#### 溢出判断

- 方法一：**运算数与结果数的符号位比较**


<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606172936162.png" alt="image-20220606172936162" style="zoom:67%;" />

- A~S~为被加数符号位、B~S~为加数符号位、S~s~为结果的符号位；ABS相**与**、+表示相**或**、横杠表示取反

- V=1时 即前半部分或后半部分为1，前半部分为1时 A1B1S0即正加正得负 溢出、后半部分为1时 A0B0S1即负加负得正 溢出

  

- 方法二：**符号位与数值最高位的进位值不同时，有溢出**


<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606173030629.png" alt="image-20220606173030629" style="zoom:67%;" />

- 符号位与数值最高位进行异或 
  - 不同为1：有溢出；
  - 相同为0：没溢出



- 方法三：**双符号位 00或11没溢出；10-下溢；01-上溢**

  - 双符号位进行异或 不同为1-有溢出；相同为0-没溢出

  - 存储时只存1个符号位 运算时复制一个符号位，所以不多占内存




#### 符号扩展



### 3.3 定点数运算

#### 原码一位乘法

两数相乘，两个数的**符号位**进行异或（符号相同为0 结果为正；符号不同异或为1 结果必为负），两数的数值位取绝对值进行乘法计算



- 计算机如何进行数值位绝对值的乘法？
  1. ACC累加寄存器：乘积高位；MQ乘商寄存器：乘数、乘积低位；X通用操作数寄存器：被乘数
  
  2. 正式乘法之前 ACC置为0
  
  3. 从MQ依次取最低位 为1--ACC加上被乘数，为0--ACC加上0
  
  4. 接着ACC与MQ均**逻辑右移**（高位补0） ACC**最低位进入MQ** MQ最低位因为已经用完了 所以右移丢弃，再MQ取最低位（以此来实现乘法中的**错位**相加 如上图的错位）
  
  5. n个数值位 右移n次
  
  6. 记得修改符号位--异或的结果
  
     

#### 补码乘法



辅助位初始化为0

#### 原码除法

1. 恢复余数法

ACC累加器：被除数、余数；MQ：商；X：除数

符号位单独处理，进行异或；只进行绝对值的除法

相除时，计算机默认商1，然后将两数相减（即加上减数的补码），若结果是负数，则说明应该商0，恢复余数

相除得到正确的一位商后，ACC和MQ逻辑左移 ACC最高位丢弃 MQ最高位进入ACC MQ最低位因为是逻辑左移所以补0

计算机进行减法：a-b == a+[b]~补~ b的补码就是b全部按位取反加1



注意因为是0.1011 / 0.1101 相除时两数同乘了2^4^，所以最终余数0.0111就要乘2^-4^



2. 不恢复余数：加减交替法

恢复余数是当商1相减后结果为负时 又要加回除数，再逻辑左移（相当于乘以2）后再减去除数（即加上除数的补码）

加减交替是不恢复余数，相减后结果为正就商1 **4**

再**减去除数**（加上除数的补码）为负就商0 逻辑左移**再加上除数**（就是加上除数 不是加上除数的补码！），但 直接 得到的就是下一次的余数

但最后一步仍需要恢复余数！！最后一步商1时结果为负数，仍改为商0并加上除数来恢复余数



加减交替推导过程：



由于上述讨论的是定点小数的除法 所以被除数必须小于除数 得到的商才是小数 否则商大于1就不能用定点小数表示；计算机检测被除数是否大于除数：第一次如果就可以商1 则被除数肯定大于除数 此时计算机就停止执行这两个数的除法

#### 补码除法

符号位不单独异或 而是直接参与运算；被除数 除数 余数使用双符号位

- 第一步：被除数和除数同号，则被除数减去除数；异号，则被除数加上除数

- 此后：余数和除数同号 商1 余数左移一位 再减去除数

  ​		   余数和除数异号 商0 余数左移一位 再加上除数

- 末位商恒为1 ！！



### 3.4 C语言强制类型转换



### 3.5 数据的存储和排列

#### 大小端模式

低地址为端

大端：最高有效字节MSB 在低地址

小端：最低有效字节LSB 在高地址（低对低 高对高）



### 3.6 浮点数运算

#### 浮点数的加减运算⭐

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606173435434.png" alt="image-20220606173435434" style="zoom:67%;" />

- 对阶是小阶向大阶对齐
  - 小阶码数值增大时，尾数部分应右移，舍去的是尾数低位，对精度影响小。
- 溢出
  - 阶码上溢：认定为异常 中断；
    - ⭐溢出判断：根据运算结果的阶码来判断是否溢出，当阶码大于最大正阶码时即为溢出。
  - 下溢：按机器0处理
- 规格化

- **通常用双符号位表示尾数 可以拯救尾数溢出**

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606173555508.png" alt="image-20220606173555508" style="zoom:67%;" />

上例中需要注意的地方：

1. 分数化为浮点数表示：分子和分母的处理
2. 对阶求阶差：上例阶差为-1说明X的阶比Y的阶小1，所以X的阶要加1 加1后X的尾数应算术右移
3. 尾数相减后 两符号位不一样，说明尾数溢出 要规格化，即尾数右移一位，阶码加1

舍入方法：

1. 0舍1入：若舍去的最高位为1 则在尾数末尾加1，加1后可能尾数又溢出 要右规

2. 恒置为1：右移后尾数末位恒置为1

   

#### 强制类型转换



### 3.7 算术逻辑单元ALU

&& 优先级高于 ||

&&类比乘法；||类比加法；满足分配律和结合律



异或的应用：奇偶校验

1. 求偶校验：各个位异或 结果就是偶校验位（奇数个1异或结果为1，偶数个1异或结果为0）
2. 进行偶校验：所有位进行异或，结果为1说明出错

#### 一位全加器

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606191741808.png" alt="image-20220606191741808" style="zoom:67%;" />

#### 串行加法器

只有一个全加器，数据逐位串行送入加法器进行运算

操作数长n位，加法就要分n次进行

#### 串行进位的并行加法器

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606191854034.png" alt="image-20220606191854034" style="zoom: 67%;" />

#### 优化：先行进位加法器

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606191920278.png" alt="image-20220606191920278" style="zoom: 67%;" />

#### 组内并行、组件串/并行进位ALU

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606191941315.png" alt="image-20220606191941315" style="zoom: 67%;" />



### 3.8 补码一位乘法（booth算法）电路逻辑



- A存放部分积，Q存放乘数，X存放被乘数

- 长度为n+2

  - booth算法需要两位符号位

- 移位和加控制逻辑

  - 受到Q寄存器末2位乘数控制

    当为01时，A（部分积）,X（被乘数）内容相加后一起右移1位

- I：n
- II：n+1
- III: 00,11
- IV: 01
- V:10
- GM:乘法标记
- 部分积：因为乘法是通过移位相加来实现的,在不断的移位相加时,有一个寄存器存放最后乘完之前的暂存积.这个**暂时的积**就是部分积。

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606222918148.png" alt="image-20220606222918148" style="zoom:80%;" />



# 4 存储器



## 概要

- **思路**
  - 搭建存储器模型，存储器提供了一些对外的接口，以便能与CPU协同工作；由于CPU与主存速度差距大，为提高效率：

- ① 提高存储器本身速度
  - 双端口、多模块（如m个模块的低位交叉编址，可将带宽提升为m倍），但优化后速度差距依然大，所以：
- ② 更高速的存储单元设计
  - 存储器价格上升容量下降；所以：
- **③ 局部性原理**
  - Cache-主存级；
  - 主存-辅存级；
- Cache与主存的协调
  - 主存中的块放到Cache的哪个位置--①全相联映射；②直接映射；③组相连映射



## 分类

- 按存储介质分：
   1. 磁存储器（硬盘 磁盘）
   2. 半导体存储器：双极型（TTL、ECL）；金属氧化物半导体存储器MOS（SRAM、DRAM，内存条是DRAM）
   3. 光存储器：光盘⭐**CDROM（不是ROM，采用顺序存取方式）**

- 按存取方式分：
   1. RAM

   2. SAM顺序存取：磁带

   3. DAM直接存储器：磁盘硬盘等

      

- ⭐信息的可改写性：

   - ROM和RAM都采用随机存取方式进行信息访问
   - ROM**（只读存储器）**
      - 一部分永久存在于只读存储器中的软件称为：**固件**
      - 不需要刷新
   - RAM**（随机存取存储器）**
      - 用作cache
      - DRAM（动态随机存取存储器）：**需要刷新动态MOS存储器**
        - 因为DRAM电容上的电荷会逐渐泄露，数据只能保存较短的时间，为避免数据丢失，**必须定期采用类似读操作的方式对存储单元补充电荷，这个过程称为刷新。**
        - 动态MOS存储器采用类似读操作的方式进行刷新。DRAM的刷新是按行进行的，每次完成1行的刷新，刷新操作只需要给出存储器的行地址，不需要给出存储器的列地址。
        - 常见的刷新方式：集中刷新方式；分散刷新方式；异步刷新方式
        - ⭐DRAM采用地址复用技术，行列地址分开传送。

- 信息的可保存性：
   1. 易失性

      - RAM

   2. **非易失性：半导体ROM、闪存、磁盘、光盘**

      

- 存取速度和功能：直接与CPU交换信息的是主存和Cache
   1. 寄存器存储器
   2. Cache高速缓存
   3. 主存储器
   4. 辅存/外存储器

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607110625987.png" alt="image-20220607110625987" style="zoom:67%;" />

**主存储器：存储体 + MAR地址寄存器 + MDR数据寄存器**（MAR和MDR实际中是做在CPU上的）



- **主存 = RAM（存放更详细的、运行中程序的信息，速度快但易失）+ ROM（存放开机后必要的一些指令给CPU读取，速度慢）**

- 存储元构成存储单元，存储单元构成存储体，一个存储单元可读写的字的二进制位数叫存储字长

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607110740051.png" alt="image-20220607110740051" style="zoom:80%;" />

- n位地址--n位地址线 -- 2^n^个存储单元；
- n数据线--n位存储字长；总
- 容量=存储单元个数（行）× 存储字长（列），基本结构如下：

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607110835756.png" alt="image-20220607110835756" style="zoom: 80%;" />

- 译码器
  - 把二进制形式地址**映射**成对于整个存储体只有一行有效信号、其他行无效信号的器件（因为多行有效会有冲突）

- 片选线CS
  - 存储器的开关；两种模式--低电平有效（CS上加了一个横杠时表示低电平即0有效） 或 高电平有效；是一根单一的线，一个二进制位
  - 单片存储芯片的容量有限，通常需要将多片存储芯片按照一定的方式组织起来，并与CPU连接，从而获得一个大容量的存储器。
  - 通过设置片选端，**可以由地址线经译码电路得到片选信号，从而选择不同的存储器芯片**。

- 寻址：就是按不同大小的单元切割整个存储器（如每个单元为4B 即字长4B），问这样切割后由多少个单元（即总容量 除以 每个单元的位数）


<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607111334031.png" alt="image-20220607111334031" style="zoom:80%;" />



## 存储器性能指标

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607111402209.png" alt="image-20220607111402209" style="zoom:80%;" />

## 4.1 半导体存储器

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607111427121.png" alt="image-20220607111427121" style="zoom:80%;" />

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607111524726.png" alt="image-20220607111524726" style="zoom: 67%;" />

- 对外四个接口：**地址线、数据线、片选线、读写控制线**



### RAM随机存取

- 访问存储单元与其所在存储体中物理位置无关--随机存取




#### DRAM的刷新

- DRAM由于电容失去电荷，所以要刷新：刷新有硬件支持，读出一行信息后重新写入，占用1个读或写周期


1. **不需要CPU控制，存储器独立完成**
2. 以行为单位，仅需要行地址
3. 存储器中所有芯片同时刷新

- 三种刷新方式：最好的是异步刷新




#### **DRAM地址复用技术、RAS、CAS**

- DRAM采用地址复用技术
  - 如地址线有n根，采用地址复用技术时 通过行选通、列选通两次传送地址信号——因此**地址线减半为n/2**
  - 刷新时按行刷新，**行选通信号RAS、列选通信号CAS**（上面都有横杠）
- DRAM无片选信号 由RAS、CAS代替



#### DRAM与SRAM比较（都易失）

- SRAM
  - 双稳态触发器（MOS）存储信息，速度快 成本高 集成度低
  - ——常用作高速缓存**cache**

- DRAM

  - 栅极电容存储信息，需要刷新 速度慢成本低
  - ——作主存

  

### ROM只读（辅存）

- 存储器由MOS管组成，是一种半导体存储器
- 掉电后信息不丢失，是一种非易失存储器
- 采用随机访问方式，可代替计算机外部存储器

- **分类**

1. 掩膜式MROM
2. 一次可编程PROM
3. 可擦除可编程EPROM：紫外线擦除 整个擦除
4. 电可擦除可编程EERPOM：针对特定区域擦除
5. 闪存Flash Memory⭐
   - 如U盘，读快写慢（而DRAM读慢写快）
   - 闪存写入时必须先擦除原有的数据，因此写速度比读速度慢

6. 固态硬盘Solid State Drives



## 4.2 主存与CPU的连接⭐

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607104359220.png" alt="image-20220607104359220" style="zoom:80%;" />

### 位扩展

- 上图可连接8个芯片（因为CPU有8根数据线，希望同时处理8位数据），每个芯片的地址线都一样是0~12号——连接8芯片后，位扩展相当于8K×8位的存储器


### 字扩展

#### 线选法

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607104829115.png" alt="image-20220607104829115" style="zoom:80%;" />

- 由于不能有00 11两种状态（因为00--两芯片都没有数据；11--都有数据 冲突）所以浪费了这两个——地址空间不连续，而译码片选法利用了所有状态——地址空间可连续（可实现00..0到11..1的连续变化），可增加逻辑设计


#### 译码片选法

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607104853433.png" alt="image-20220607104853433" style="zoom:80%;" />

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607104957781.png" alt="image-20220607104957781" style="zoom:80%;" />

### 字位扩展

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607105027508.png" alt="image-20220607105027508" style="zoom:80%;" />

### 例题

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607105050600.png" alt="image-20220607105050600" style="zoom:80%;" />

步骤：

1. 地址线有几根、数据线有几根
2. 地址空间：**系统程序区ROM，用户程序区RAM**，把地址的16进制化为十进制与芯片大小比较，得出所选芯片
3. 多余的地址线，从低往高选出片选线
4. 余下的作为使能端



### 20年考题

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607131749682.png" alt="image-20220607131749682" style="zoom:80%;" />

- **解答：**
- 系统程序区域：ROM
- 用户程序区、系统程序工作区：RAM

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607132202973.png" alt="image-20220607132202973" style="zoom: 67%;" />

<img src="file:///C:\Users\icebear\Documents\Tencent Files\1822327087\Image\C2C\B2FB3925AD3E342DCB9D7CC1D8C5B2A6.jpg" alt="img" style="zoom:80%;" />



- MREQ：访存控制信号

- ROM
  - 需要有**接地信号！**
  - 接连数据线，片内地址线（2的12次方，从A0连接到A11）
- RAM
  - 需要连接**读写线WR！**
  - 连接数据线
  - 片内地址线
    - 系统程序工作区：位拓展（4k是2的12次方，地址线从A0到A11）
    - 用户程序区
      - 字拓展（地址线从A0到A12）
      - 连接一个译码器**（线选法）**





## 4.3 双口RAM、多模块存储器



双口RAM、多模块存储器提高存储器工作速度

- 存取周期 = 存取时间 + 恢复时间；
- 对于存储器工作的优化在于能否利用恢复时间——对多个不同时间能进行不同存取的存储单元进行并行操作，或流水线操作（一个单元进入恢复时间 其他单元进行存取）
- 存储器进行连续读或写操作所允许的最短间隔时间



### 双端口RAM

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607142710577.png" alt="image-20220607142710577" style="zoom:80%;" />

### 多模块

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607142740008.png" alt="image-20220607142740008" style="zoom:80%;" />



#### 多体并行存储器

- 低位交叉编址
  - 顺序编址模式

- 高位交叉编址

  - 交叉编址模式

  - CPU 采用交叉访问的方式，使得多体之间的读写工作重叠。
  - 可以使得存储器在一个存取周期内，向 CPU 提供更多的存储字长，达到提高存储器带宽的目的。
  - 冲突问题⭐
    - 如4体交叉编址存储器，当相邻的4次访问中，出现访问相同的模块，可能发生冲突。

- 求两种编码方式下的存储器带宽⭐

  - 顺序存储，读取3个字的时间：n*存取周期，每次都要分开去用一个存取周期

  - 交叉存储，读取3个字的时间：1个存取周期+传输周期*（n-1）

<img src="https://img-blog.csdnimg.cn/2019062411120287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQxMDY2NDQ=,size_16,color_FFFFFF,t_70" alt="查看源图像" style="zoom:50%;" />

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220609211636248.png" alt="image-20220609211636248" style="zoom:33%;" />



## 4.4 Cache高速缓冲存储器⭐



### **计算机系统中采用层次化存储体系结构的目的**

- 存储系统层次结构
  - 利用**程序局部性的原理**，从系统级角度**将速度、容量、成本各异的存储器有机组合**在一起，全方位优化存储系统的各项性能指标；

- **上层存储器可以为下层存储器做缓冲，将经常使用数据的副本调度到上层，**这样CPU只需要访问上层快速的小容量存储器，即可获得大部分数据。

- 传输单位

  - **CPU与主存：以字为单位**

  - **主存与Cache：以块为单位**

- Cache工作原理：


<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606164714483.png" alt="image-20220606164714483" style="zoom:67%;" />

### 局部性原理

- 程序局部性
  - 在一段时间内，整个程序的执行仅限从于程序中的某一部分（时间）；
  - 执行程序所需的指令和数据也仅局限于某个存储区域内（空间）

- 时间局部性
  - 当程序访问一个存储位置时，该位置在未来可能会被多次访问

- 空间局部性
  - 程序访问了某存储单元，其附近的存储单元也即将被访问

- 概念：


1. 命中率：**CPU欲访问的信息已在Cache中的比例**

   缺失率：1-命中率

2. **主存系统平均访问时间**：Cache存取时间\*命中率+主存存取时\*缺失率

3. 系统效率：**访问Cache时间 / 访问主存平均时间**，意思是该存储系统与只使用Cache的情况有多接近

4. 存储器性能：使用主存系统平均访问时间 **与** 只有主存没有Cache的情况相比，性能提升了多少

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606174643886.png" alt="image-20220606174643886" style="zoom:67%;" />

- 两种访问方式：

  - ①先访问Cache，发现Cache中没有想要的，再访问主存；

  - ②同时访问Cache和主存，若Cache中有则中断访问主存；没有就访问主存

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606221405996.png" alt="image-20220606221405996" style="zoom:80%;" />



### Cache读写流程

1. cache读流程：

   <img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606182307171.png" alt="image-20220606182307171" style="zoom:67%;" />

   1. CPU给出主存读地址RA（Read Address，包括块地址和块内偏移），以RA的块地址为关键字在cache中进行查找，如果找到则表示命中，此时通过访问cache就可获取数据
   2. 如果在cache中找不到则表示数据缺失（不命中），此时需要访问主存，并将地址为RA的主存块调入cache中，同时发送到CPU中
   3. 若cache已经满了，还需要进行替换（淘汰掉cache中的某一块），并更新查找表

2. cache写流程：
   
   <img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606182130443.png" alt="image-20220606182130443" style="zoom:67%;" />
   
   - CPU**给出主存写地址WA**（Write Address，包括块地址和块内偏移），**以WA的块地址为关键字在cache中进行查找**，如果找到则表示命中（**需要对应tag来寻找，组相联就在一个组里面找，所以组号不用包括在tag中**），此时将地址为WA的数据写入cache中，并根据写策略决定要不要同时写入主存（如果是写回策略，则不需要同时写入主存；如果是写穿策略则需要同时写入主存）
     - 写回法：只修改cache内容，当此行被替换出去时再写入主存
     - 写穿法：cache和主存一块修改
   - 如果找不到则表示数据缺失，此时若采用**写分配法**，则将地址为WA的主存块调入cache中，再进行数据写入cache的操作；如果不采用写分配法，**则直接将数据写入到主存中**
   - 若cache已经满了，还需要进行替换（淘汰掉cache中的某一块），并更新查找表
   - 脏数据：新写入cache中的数据与主存中的原始数据不一致时，新写入cache中的数据



### 4.4.1 地址映射

- 主存数据的地址映射到Cache
- **由硬件自动完成⭐**
  - 而虚拟存储器的地址映射由操作系统完成

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606165227250.png" alt="image-20220606165227250" style="zoom:80%;" />

⭐⭐⭐

- 主存物理地址：块号+块内地址
- 1. 全相联映射：标记+块内地址
  2. 直接映射：**标记**+**Cache行号**+块内地址
  3. 组相联映射：标记+组号+块内地址

- Cache行：数据位+Tag位+(LRU:**访问就归0**)+(脏位:**写回法**)+有效位

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606165307986.png" alt="image-20220606165307986" style="zoom:67%;" />

- 标记项中的**主存字块标记：记录该数据来自主存中的哪个位置**
  - ⭐访问Cache时，主存字块标记需要和cache的全部标记位进行比较
  - ⭐通常采用“按内容寻址”的**相联存储器**

- 全相联映射
  - 因为是随机放入Cache，所以除了字块内地址，其余地址都要存入Cache；全相联映射可以有空位就存；

- 直接映射
  - Cache字块地址与Cache一一对应不需要存 所以该方法存的位数比全相联映射少，但利用率低 命中率低 冲突率高（因为某数据只能存到与Cache对应的地址 。）直接映射类似哈希表：取余后存入对应区域
- 组相连映射
  - 相同组中的数据有空位就存



### 4.4.2 替换算法

- 替换算法：解决Cache满了之后去掉哪些数据


<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606182706585.png" alt="image-20220606182706585" style="zoom:67%;" />

- 随机算法RAND

- 先进先出FIFO

- **近期**最少使用LRU：**访问一次就清零**

  - Least Recently Used

- 最不经常使用LFU：**访问一次就++**

  - Least Frequently Used

  

### 例题：命中次数

全相联映射的命中次数

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606183813484.png" alt="image-20220606183813484" style="zoom:80%;" />

直接映射命中次数

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606183856288.png" alt="image-20220606183856288" style="zoom: 80%;" />

组相连映射 + FIFO：用表格更清晰

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606183930980.png" alt="image-20220606183930980" style="zoom: 80%;" />

组相连映射 + LRU：

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606183948542.png" alt="image-20220606183948542" style="zoom:80%;" />



### 4.4.3 写策略

写策略：解决Cache中的内容被修改后如何让主存保持一致

- 命中时（写操作的数据已经在Cache中）：


1. **写回法：设置脏位，标志该位置是否被修改过**（不需要额外数据缓冲，考虑了局部性原理，当**该块要被替换时才写入主存**）
2. 全写法/写直通法：写命中时就修改数据，使用写缓冲可暂存一些写操作（保持了一致性，但在写的频率很高时候会溢出 因为CPU交付数据给写缓冲很快 但写缓冲向主存写数据很慢）

- 未命中时（写操作的数据还在主存，不在Cache）：


1. 写分配法：把主存中的块调入Cache，配合写回法使用
2. 非写分配法：直接写入主存，配合全写法使用



#### 多级Cache



### 例题：二进制映射

十进制地址映射要用取余来分组、求商来标记

二进制地址映射 直接把地址划分为相应的位（主存字块标记、Cache字块标记或组地址、字块内地址等）



### 例题：计算Cache容量



## 4.5 虚拟存储器

- **提高存储系统容量**
- **扩大存储器的寻址空间**



<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606163814441.png" alt="image-20220606163814441" style="zoom:67%;" />

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607152515200.png" alt="image-20220607152515200" style="zoom:80%;" />

- 当CPU要访问的页面不存在时，CPU检测到异常便会产生缺页异常。请求操作系统将所缺页调入内存。缺页处理由缺页中断处理程序完成。根据发生缺页故障的地址从外存读入所缺失的页，缺页处理完成后回到发生缺页的指令继续执行。



### 页式虚拟存储器

- 一个程序（进程）在逻辑上划分为若干个大小相等的”页面“。
- 页面的大小与块的大小相同，每个页面可以离散地放入不同主存块中。
  - 主存的页：实际页；虚存：虚页
- 虚拟存储器中，当程序执行时，由**操作系统⭐**完成地址映射（通过”页表“将逻辑地址映射为实际地址）
- 页表的作用：**记录每个逻辑页面存放在哪个主存块中**。（存在主存）
- **页表基址寄存器**
  - 存的是**页表**的起始地址和页表的长度；
  - 指明页表在主存中的存放地址

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-image\image-20220609220903386.png" alt="image-20220609220903386" style="zoom:50%;" />

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220609221405169.png" alt="image-20220609221405169" style="zoom: 33%;" />

⭐⭐⭐

- **逻辑地址**
  - **虚页地址 = 虚页号VPN + （虚拟页偏移VPO⭐）；**

- **实际地址**
  - **主存地址/页框号/实页号 = 实页号PPN + （页内地址/物理页偏移PPO⭐）**

⭐⭐⭐



- 页表存放在主存中


- **页表起始地址+虚页号**（偏移量）=页表项地址

- **页表项地址** = **实页号** + 有效位 + 修改位、使用位、权限位等
  - （有效位为1--表示该虚拟地址指向的数据是在主存中，直接把该处**实页号+页内地址**拼接就可实现虚页到实页地址的映射，可在主存中访问该数据；为0--在辅存中还没拿进，就要操作系统控制调入主存）

- 得到实页地址后就去Cache-主存体系，在Cache就访问，不在就去主存




#### 慢表、快表

- 快表中存储的是慢表的一些页表项的副本
  - 加快地址变换的速度
  - 相联存储器：根据内容查找
- Cache中存储的是主存块的副本
  - 对物理地址访问速度加快

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606164118007.png" alt="image-20220606164118007" style="zoom: 80%;" />

### 例题：快表慢表、虚实映射

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606164202812.png" alt="image-20220606164202812" style="zoom:67%;" />

- 快表有效位为1：可以映射到实地址；

- 快表有效位为0：表示不在快表中，就到慢表中去找

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220609222117084.png" alt="image-20220609222117084" style="zoom: 33%;" />



### 段式虚拟寄存器

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606164223215.png" alt="image-20220606164223215" style="zoom:67%;" />



### 段页式

- 先分段，再分页


![image-20220606164240954](C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606164240954.png)



# 5 指令系统

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606164340885.png" alt="image-20220606164340885" style="zoom:80%;" />



- 指令：计算机运行的最小单位




## CPU功能和结构

- CPU（运算器+控制器）功能：


1. 指令控制：程序的顺序控制，取出分析执行指令
2. 操作控制：管理并产生由**内存取出**的每条指令的操作信号并送往相应部件
3. 时间控制：按时间顺序提供操作信号
4. 数据加工：数据算术和逻辑运算
5. 中断处理：异常情况和特殊请求处理

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606220028899.png" alt="image-20220606220028899" style="zoom:80%;" />



- 运算器基本结构：


1. 算术逻辑单元ALU：算数/逻辑运算
2. 通用寄存器组：如SP指示栈顶地址
3. 暂存寄存器：功能之一是暂存主存读来的数据，当两个操作数一个来自主存、另一个来自寄存器，若先把主存的操作数读到寄存器，则会覆盖，所以要把主存的读到暂存寄存器
4. 累加寄存器：暂存ALU运算结果，实现加法运算
5. 程序状态字寄存器（按位寻址寄存器）：OF溢出、SF符号位、ZF、CF
6. 移位器
7. 计数器：计数乘除的操作步数

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606220126185.png" alt="image-20220606220126185" style="zoom:80%;" />

- 如何将数据由通用寄存器组传到ALU：


1. 专用数据通路方式：性能高，基本无数据冲突；结构复杂、硬件量大、不易实现
   1. 多路选择器MUX
   2. 三态门：为1时数据可以输出，为0就不行
   
2. CPU内部单总线方式：结构简单易于实现；数据可能冲突，性能低

   

### 指令格式

- 指令 = 操作码+地址码


- 对地址码的设计：四地址、三地址、二地址、一地址、零地址


- 定长指令字结构（指令长度不变）；零地址变成只有操作码了—变长指令字结构（指令长度不等）


<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607103659551.png" alt="image-20220607103659551" style="zoom:67%;" />

#### 扩展操作码

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607103723320.png" alt="image-20220607103723320" style="zoom:80%;" />

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607103744773.png" alt="image-20220607103744773" style="zoom:80%;" />

#### 操作码类型

1. 数据传送：LOAD（存储器的数据放到寄存器）、STORE（寄存器到存储器）
2. 算术逻辑运算
3. 移位操作
4. 转移操作：无条件/条件、CALL/RETURN、陷阱指令
5. 输入输出操作：CPU寄存器与IO端口之间的操作

### 指令寻址

- 数据存放：


1. 按字节编址：每个字节存储单元都有一个地址编号

   按字节地址寻址：给出一个字节地址，可以取出长度为一个字节的数据

   按字编址/按字寻址

2. 大端、小端（低对低）

3. 边界对齐

> 机器字长：CPU一次能处理的二进制位数（因为放到CPU的寄存器中 所以机器字长与寄存器位数有关）
>
> 指令字长：一个指令字中的二进制位数
>
> 存储字长：一个存储单元（一般指字存储单元，一般取字节的整数倍）二进制位数
>
> 单字长指令：指令长度=机器字长的指令
>
> 半字长指令、双字长指令

- **指令寻址**
  - **定位下一条指令的地址**——顺序寻址（PC自增）
  - 跳跃寻址

- **数据寻址**
  - 确定本条指令的操作数地址



### 数据寻址⭐

- 操作数类型：


1. 地址：无符号数
2. 数字：定点数 浮点数 十进制数
3. 字符：ASCII码
4. 逻辑数：逻辑运算

- 寻址方法：


1. **立即寻址：**形式地址就是操作数本身（补码），#表示（取指令1次）

   ![image-20220605143841866](C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605143841866.png)

   <img src="pic\图片1.png" alt="图片" style="zoom:67%;" />

3. **直接寻址：**形式地址就是操作数的真实地址EA（取指令1次、执行指令即取操作数1次）

   ![image-20220605143915849](C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605143915849.png)

4. **间接寻址**：

   ![image-20220605144112118](C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605144112118.png)

5. **寄存器寻址：**只需访存取指令，不需访问主存来获得数据

   ![image-20220605143954805](C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605143954805.png)

5. **寄存器间接寻址：**寄存器给出的不是操作数，而是操作数所在主存单元的地址，到主存中取数据

   ![image-20220605144135461](C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605144135461.png)

6. **相对寻址：**

   - 将程序计数器PC中的内容加上指令中的形式地址D，形成操作数的有效地址。


   - **注意：**因为取指过程中PC的值会修改，而计算操作数的有效地址则在指令译码分析或执行阶段完成。

   上式中的PC内容应为PC当前值，也就是下一条将要执行指令的地址值，所以有EA=PC+1+D。1是一条指令的长度。

   A可正可负，补码表示

   ![image-20220605144201192](C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605144201192.png)

7. 基址寻址：

   - **基址寄存器BR，其内容不可变**，指向基地址，可以用户指定一个通用寄存器为BR，此时需要在指令中指出哪个做BR，但采用默认BR时不需指出，隐含寻址

   程序在主存中可以改变位置（只要改变BR）仍能运行，因为只要改变BR后++就能取到该程序其他数据

   <img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605144426296.png" alt="image-20220605144426296" style="zoom:67%;" />

8. **变址寻址**
   - 寄存器存放变化的地址，加上D就是真正的地址EA

![image-20220605144250975](C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605144250975.png)

- 例题：实现数组累加，D中为数组首元素地址（放在基址寄存器中），X为变址寄存器，LDA中的A是ACC累加寄存器，#后表示立即数寻址

9.堆栈寻址：

- 堆栈指针SP、操作POP、PUSH

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605144743382.png" alt="image-20220605144743382" style="zoom:67%;" />

10. 隐含寻址

- 指令中隐含操作数地址

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605144809198.png" alt="image-20220605144809198" style="zoom:67%;" />

#### 例题：PC跳转求形式地址

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607103905785.png" alt="image-20220607103905785" style="zoom:80%;" />

### CISC和RISC

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605152619171.png" alt="image-20220605152619171" style="zoom:67%;" />

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605152641164.png" alt="image-20220605152641164" style="zoom:67%;" />

## 指令执行过程

- 指令周期：CPU从主存中取出并执行一条指令的全部时间

- **机器周期**/**CPU周期**：一条指令中的多个步骤中的一个
- 时钟周期/节拍/**CPU时钟周期**：一个机器周期有多个时钟周期，CPU操作的最基本单位


<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605160231071.png" alt="image-20220605160231071" style="zoom:67%;" />

**取指周期**：

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605160255223.png" alt="image-20220605160255223" style="zoom:67%;" />

间址周期：**AD(IR)指的是指令IR中的地址码部分AD**

（将间址的有效地址EA存入IR）

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605160419019.png" alt="image-20220605160419019" style="zoom:67%;" />

执行周期：根据IR中的指令字的操作码和操作数通过ALU操作产生执行结果

中断周期：

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605160730113.png" alt="image-20220605160730113" style="zoom:67%;" />



**指令执行方案：**

1.单指令周期

- 指令执行过程中数据通路的任何资源都不能被重复使用，所以应该是专用数据通路结构。
- 控制信号在一个时钟周期内不变

2.多指令周期

3.流水线周期

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605160835440.png" alt="image-20220605160835440" style="zoom:67%;" />





### 数据通路

数据通路基本结构：

1. CPU内部单总线方式
2. CPU内部多总线方式
3. 专用数据通路方式

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607104017089.png" alt="image-20220607104017089" style="zoom:80%;" />

#### CPU内部单总线方式

内部总线：同一部件内部之间的总线（如CPU内部连接各个寄存器和运算部件的总线）

系统总线：同一台计算机系统间各部件之间的连线（CPU、内存、通道、I/O设备之间的）

单总线方式的ALU需要暂存器配合（下图中的Z），多总线不需要

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607104050975.png" alt="image-20220607104050975" style="zoom:67%;" />

#### 例题：CPU单总线

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607104122187.png" alt="image-20220607104122187" style="zoom:67%;" />

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607104146871.png" alt="image-20220607104146871" style="zoom:67%;" />

#### 专用通路

- 指令在IR中，指令的操作码OP到CU控制器去译码


**取指令**：

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607150217694.png" alt="image-20220607150217694" style="zoom:80%;" />

#### 例题：专用通路

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607150327007.png" alt="image-20220607150327007" style="zoom:80%;" />

- 自动+1---PC；PC内容是地址，送MAR；与微操作信号发生器相连---IR；与主存相连---MAR、MDR

- 取指令过程：(PC)-->MAR; M(MAR)-->MDR; (MDR)-->IR


<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607150355859.png" alt="image-20220607150355859" style="zoom:80%;" />

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607150418266.png" alt="image-20220607150418266" style="zoom:80%;" />



## 控制器

- 对内部的控制

  - 根据控制信号，构建一系列数据通路，来完成微操作序列的功能

- 对外部（内存、I/O设备）的控制

  - 依靠一组系统总线（数据总线、地址总线、控制总线）

- 定位设备--地址总线、安排任务--控制总线

- 地址、控制信号由CPU发出 

  - 线是单向的；

- 数据总线是双向的

  

**控制器（控制单元）的功能：**

1. 从主存取指令、**指出下一条指令在主存中的位置**
2. **对指令译码**或测试，**产生相应的操作控制信号**
3. 指挥并控制CPU、主存、I/O设备之间的数据流动方向

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606220305227.png" alt="image-20220606220305227"  />

CU的输入和输出：

![image-20220606220631444](C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606220631444.png)



### 控制器的设计

- #### CPU控制方式


1. 同步控制：定长、不定长的机器周期

2. 异步控制：不存在基准时标信号，各部件按自身固有速度工作，通过应答方式联络

   运行速度快、控制电路复杂

3. 联合控制：对不同指令的微操作大部分同步控制、小部分异步控制



#### 微操作时序设计⭐

非访存指令：CAA ACC清零；COM ACC取反；STP 停机；SHR/L 算术右/左边移；CSL/R循环移位；

访存指令：ADD、STA 从ACC存数到主存；LDA 从主存取数到ACC；JMP；BAN

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607151636087.png" alt="image-20220607151636087" style="zoom:80%;" />



#### 电路设计：组合逻辑电路设计

步骤：列出操作时间表---写出**微操作命令**最简表达式---画出逻辑图

##### 列出时间表

取指周期：

间址周期：

执行周期：

##### 写出最简表达式⭐

-  M（MAR）->MDR
  - 根据下面的图片判断，与门则说明T1和FE、IND、EX之间是·
    - **T1·FE+T1·IND·(LDA+ADD+JMP+BAN+STA)+T1·EX·(LDA+ADD)**
  - FE（取指） 周期代表**根据指令地址（MAR）去内存取指**；
  - IND （间址）周期代表根据操作数的形式地址（MAR）**去内存取操作数的有效地址**；
  - EX （执行）周期代表根据操作数地址（MAR）去内存**取操作数**
    - **JMP:  AD(IR) -> PC**
  - LDA/ADD/JMP/BAN/STA这些是指令。一个指令又对应了一个微操作序列。

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607130259205.png" alt="image-20220607130259205" style="zoom:80%;" />

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607131158625.png" alt="image-20220607131158625" style="zoom:67%;" />

### 控制器的设计：微程序

- **微程序、微指令、微命令、微操作**
  - **一个微程序（对应一个机器指令）有多个微指令**
  - **一个微指令中可能包含多个微命令**
  - **微命令和微操作一一对应**
- 控制单元CU**的控制信号⭐**
  - 向主存
    - 读写R/W控制信号、片选CS信号
    - ⭐因为存储器是由一定容量和规格的存储芯片构成的，存储器地址由高位的片选地址和片内地址两部分构成。为了保证译码正确，必须增加**片选信号**
  - 向ALU
    - 运算器工作方式控制型号、控制运算器运算的脉冲信号
  - 向外设
    - 查询信号INTR、HLDA（总线响应）信号



<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605161506328.png" alt="image-20220605161506328" style="zoom:67%;" />

- 硬布线工作原理：微操作控制信号**由组合逻辑电路根据当前状态指令码、状态、时序，即时产生**

- ##### 微程序工作原理：事先把**微操作控制信号**存储在一个**专门的存储器（控制存储器）**，把**每一条机器指令**编写成一个微程序，这些微程序可以存到一个控制存储器中，用寻址用户程序机器指令的办法来寻址每个微程序中的微指令

- 相容性微命令：可同时产生、共同完成某一些微操作的微命令 
-  互斥性微命令：不能同时出现

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605164037836.png" alt="image-20220605164037836" style="zoom:67%;" />



- ⭐**一条机器指令对应一个微程序**
- **微程序由多条微指令构成**
- **相容性微命令可以在同一个微指令中；**
- **取指周期的取指令操作的微命令编成微程序，微程序存入ROM**



#### 微程序控制器基本结构

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605162124817.png" alt="image-20220605162124817" style="zoom:67%;" />

**控制存储器CM、CMAR、CMDR**

- CMAR：控存地址寄存器（接受为地址形成部件送来的微地址，为在CM中读取微指令作准备）

- CMDR：微指令寄存器，存放从CM取出的微指令

- 顺序逻辑：控制执行顺序（可能发生中断）

- 过程原理

  - 1. 指令操作码送给微地址形成部件，**用来确定微指令序列的起始地址**

  - 2. 根据顺序逻辑标志确定**执行微指令地址**

  - 3. 将微指令放入**CMAR**中

  - 4. 经过**地址译码器的译码**，就可以选中CMAR所指向的微指令

  - 5. 从CM取出微指令，放入CMDR中

  -    6.CMDR

    - 把下地址**（接下来执行指令的地址）**送给顺序逻辑，顺序逻辑根据标志性信息再来决定下一条应该执行的微指令的地址

    - 硬件电路根据CMDR控制码部分，向CPU内部其他部件或者系统总线来发出控制信号。

      

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605162240974.png" alt="image-20220605162240974" style="zoom:67%;" />

#### 微指令的格式

**水平型、垂直型、混合型**

- 垂直型：一条微指令只能定义一个微命令，由微操作码字段规定具体功能（指出这条微指令对应的微命令是哪个）
- 水平型：一条微指令能定义多个可并行的微命令

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605162307129.png" alt="image-20220605162307129" style="zoom:67%;" />

#### 微指令的编码（控制）方式（**水平型**）⭐

- 如何对微指令的控制字段编码而形成控制信号

##### **直接编码方式：**

- 在操作控制字段中，每一位对应一个微操作指令，为1表示控制信号有效


<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605170839853.png" alt="image-20220605170839853" style="zoom:67%;" />

- 优点：直观简单、执行速度快、操作并行性好


- 缺点：微指令字长过长，n个微指令就要n位，造成控存容量极大




##### **字段直接编码：**

将操作控制字段分成多个段，每段经过译码后产生一个控制信号（如3位为一段，则3-8译码器，可控制8个互斥性微指令的控制信号，但一般要保留一个不发出微命令的状态，所以7个控制信号）

![image-20220605170957717](C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605170957717.png)

- 分段原则：
  - ①**互斥性微指令在同一段，相容性在不同段（**利用每一段译码后**只能产生1个控制信号**）；
    - 判断互斥：控制信号没有在一条微指令中同时出现过
  - ②每个小段中包含的信息位不能太多，否则耗费译码时间和译码线路复杂性；
  - ③一般每个小段要**留出一个状态**，表示本字段不发出任何微命令，通常用000（3位为一段时）
- 优点：可缩短微指令字长

- 缺点：需要译码后再发出微命令，比直接编码慢



##### **字段间接编码/隐式编码：**

一个字段的某些微命令由另一个字段中某些微命令解释

优点：进一步缩短指令字长

缺点：削弱微指令的并行控制能力，故通常作为字段直接编码的辅助手段



##### 例题：字段直接编码

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605162614628.png" alt="image-20220605162614628" style="zoom:67%;" />



#### 微指令的地址形成方式⭐

- 如何确定下一条微指令的存放地址

##### 1.微指令的下地址字段指出（断定方式）

- 判别测试字段

  - 每一位均对应一个判别标志。有一位是译码测试位。其他判断标志都会检测状态条件反馈信号中与之对应的状态条件是否成立。
  - 当判别测试字段不符合待测试状态的状态条件时，由下地址段直接给出下一条微指令的地址。否则就需要进行微程序分支。

- 多路选择器⭐

  - 微指令字提供下址字段等多个输入。将所有可能的后续地址连接到多路选择器中输出。如下址字段放在0。
  - 多路选择器的选择控制端由条件判别测试逻辑根据判别测试字段和状态条件自动生成。
  - 输出后续地址送入微地址寄存器。

  

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220610121058941.png" alt="image-20220610121058941" style="zoom: 67%;" />

##### 2.机器指令的操作码形成

##### 3.增量计数法

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605163050186.png" alt="image-20220605163050186" style="zoom:67%;" />

##### 例题：断定方式

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605165703696.png" alt="image-20220605165703696" style="zoom:67%;" />

#### 微程序控制单元的设计

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605165740749.png" alt="image-20220605165740749" style="zoom:67%;" />

定位微程序微指令与机器指令的操作码有关（公共取指周期结束后如何转移到不同周期）

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605165804261.png" alt="image-20220605165804261" style="zoom:67%;" />

#### 其他概念

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605165827006.png" alt="image-20220605165827006" style="zoom:67%;" />

### 硬布线与微程序的比较

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605161727713.png" alt="image-20220605161727713" style="zoom:67%;" />



# 6 总线



**总线**

- 一组能为多个部件分时共享的公共信号(**如指令、操作数、中断类型号**)传送路线

**为什么要用总线**

- 解决I/O设备和主机之间连接的灵活性问题

**特点**：

- 共享：总线上可挂接多个部件，各部件之间交换的信息都可通过这组线路分时共享
- 分时：同一时刻只允许一个部件向总线发送信息

**总线的特性**：

1. 机械特性：尺寸、形状、管脚数、排列顺序
2. 电气特性：传输方向、有效电平范围
3. 功能特性：每根传输线上传的01是地址还是数据还是控制信号——地址总线 数据总线 控制总线
4. 时间特性：时序关系

**传输类型**

- 突发传输
  - **在一个总线周期中可以传输多个地址连续的数据**，在一次地址阶段可进行多次连续数据的传输。
- 并行传输
  - 在传输中有多个数据位同时在设备之间进行的传输
  - 工作频率高时，信号线直线会产生干扰，因而无法提升工作频率，这个角度看串行传输速率更高
- 串行传输
  - 数据的二进制代码在一条物理通道上以位为单位，按时间顺序逐位传输
- 同步传输
  - 传输过程由统一的时钟控制。

**总线的分类：**

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605205746575.png" alt="image-20220605205746575" style="zoom:80%;" />

- 按数据传输格式：

  - **串行总线：**如1101，一位位传输和接收

    优点：只需一根传输线，成本低，适用长距离传输，应用于计算机内部时可节省布线空间

    缺点：数据发送要拆卸数据（拆成一位一位传输）、数据接收时要装配（组装回来），要考虑串行、并行转换的问题

  - **并行总线：**如1101，四位数据一起传输

    优点：逻辑时序简单，电路实现容易

    缺点：占用更多布线空间；远距离传输成本高；工作频率较高时 并行信号线间产生严重干扰，对每条线等长的要求高，工作效率无法持续提升

- 按总线功能：

  - 片内总线：芯片内总线，CPU芯片内寄存器之间、寄存器与ALU之间的公共连接线

  - 系统总线：各功能部件（CPU、主存、I/O接口）间的总线

    按传输信息的不同：

    - 数据总线：传输数据信息（指令、操作数）

      其位长与机器字长、存储字长有关；是双向线

    - 地址总线：地址信息（主存单元、I/O端口）

      位数与主存空间大小、设备数量有关；单向

    - 控制总线：一根控制线 一个控制信号（CPU送出的控制信号、主存或外设返回CPU的反馈信号）

      每根线是单向的，但多根控制线中有出的方向 也有进的方向

  - 通信总线：计算机系统之间、或与其他系统（远程通信设备、测试设备）之间信息传送的总线，又叫外部总线



## 系统总线的结构



### 单总线结构

- CPU、主存、I/O设备（通过I/O接口）都连接在一组系统总线上，允许I/O设备之间、I/O与CPU、I/O与主存间直接交换信息
- 并非只有一根数据线，而是一组，包括**地址总线 数据总线 控制总线**
- 优点：结构简单 成本低 易于接入新设备
  
- 缺点：**带宽低 负载重，多个部件只能争用唯一的总线 且不支持并发传送操作**


![image-20220606220824949](C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606220824949.png)

### 双总线结构

- 目的
  - 降低系统总线负载，**提升CPU与主存（DRAM）之间的访问性能**。

- **主存总线**
  - CPU、主存、通道间数据传送
  - 高速存储总线。

- **I/O总线**
  - 多个**外部设备与通道**

- 主存总线--**支持突发传送**（猝发传送）
  - 送出一个地址，收到多个地址连续的数据。

- 通道：**能对I/O设备进行统一管理，放在主存中。**
  - 具有特殊功能的处理器。


<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606220924047.png" alt="image-20220606220924047" style="zoom:80%;" />

### 三总线结构⭐

- **DMA（直接内存访问）总线**：外部设备可直接访问主存 Directly Memory Access ，可直接访存的外设叫**高速外设**

- 主存总线（CPU与主存）、DMA总线（高速外设与主存）、I/O总线（CPU与外设）

- **同一时刻只能有一组总线工作**

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606221037378.png" alt="image-20220606221037378" style="zoom:80%;" />

### 单周期多周期比较

- 二者的差异主要是指令周期长度、数据通路的区别。
  - **单周期处理器中所有指令在一个时钟周期内完成**，如指令的取出和执行操作，指令执行过程中**数据通路的任何资源都不能被重复使用，都应该是专用数据通路**，而需要被多次使用的**资源都需要设置多个**，为避免访存冲突，**指令存储器和数据存储器要单独设置**。
  - 多周期处理器指令周期包括多个时钟周期，一条指令的执行过程细分为若干个更小的步骤，**每个时钟周期执行其中一部分操作，并将操作结果暂存在相关寄存器中供下一个时钟周期进行处理**，直至指令执行完毕。多周期数据通路中的功能部件可在一条指令执行过程的不同时钟周期中被多次使用，这种共享复用方式能提高硬件实现效率，所以**多周期指令存储器和数据存储器不需要分开设置**。

### 单周期的问题

- **时钟周期长，程序执行效率不高。**
- **硬件实现效率不高**
  
  - 为了在ALU运算的同时计算指令顺序地址和分支目标地址，增设了两个加法器，而加法器是占用芯片晶圆面积较多的电路。
- **指令存储器和数据存储器分离结构与实际存储系统不符。**

- 处理器的硬件作用⭐

  - 程序计数器PC
    - 用于存放下一条指令所在单元的地址的地方。
  - 指令存储器
    - 用于单独存放指令程序。
  - 数据存储器
    - 可读可写，用于存放数据。
  - 寄存器堆
    - 又称寄存器文件，是寄存器结合，CPU通过一定接口对这些寄存器进行读写访问。
  - 多路选择器⭐
    - 引入一个多路选择器就会引入一个选择控制信号sel。
    - 根据sel的值选择一路进行输入输出。
    - RegDst用于决定指令字中的rt、rd哪个字段作为目的寄存器进行写入。
    - AluSrc用于从寄存器或立即数扩展值中选择一个操作数送入ALU。
    - MemToReg用于从ALU的运算结果或主存访问数据中选择一路写回寄存器。
  - 符号扩展单元
    - 将16位立即数符号扩展成32位以便进行运算。
  - ALU
    - 用于实现指令的算术逻辑运算功能。

  <img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220610115042659.png" alt="image-20220610115042659" style="zoom: 67%;" />



## 总线的性能指标

- **总线的传输周期（总线周期）**

  - **一次总线操作所需的时间**，通常若干个总线时钟周期构成
  - 申请、寻址、传输、结束阶段

- **总线时钟周期**

  - 机器的时钟周期，计算机有一个统一的时钟控制整个计算机的各个部件

- 总线**工作频率**

  - 总线周期的倒数，**一秒内传送几次数据**
  - 若总线周期=N个时钟周期，则总线工作频率=时钟频率 / N

- 总线**时钟频率**

  - 时钟周期的倒数，**一秒内有多少个时钟周期**

- 总线宽度

  - 总线位宽，总线上能同时传输的数据位数，**数据总线的根数**

- 总线带宽

  - 数据传输率，单位时间上总线可传输的数据位数

  - 单位：B/s

  - **总线带宽 = 总线工作频率 × 总线宽度 （bits / s）= 总线宽度 / 总线周期**

    用上述公式衡量串并行总线传输速度：

    <img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605210247958.png" alt="image-20220605210247958" style="zoom: 50%;" />

  - 指的是总线本身所能达到的**最高**传输速率

  - **有效数据传输率**：去除了控制位等，只算数据位

  <img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605210342546.png" alt="image-20220605210342546" style="zoom:67%;" />

- 总线复用

  - 指的是一种信号线在不同时间传输不同信息，可以用较少的线传输更多的信息，节省空间和成本

- 信号线数

  - 地址、数据、控制总线的总和

    


## 总线仲裁

- 总线的判优控制方式中，**CPU 向 I/O 接口发出的 BG 总线同意信号**，一旦查询到满足条件的接口，则**该外设接口就会向 CPU 发送一个 BS 信号，表示总线忙状态。通知 CPU 和其他外设总线被它占用。**

  

- 总线上连接的设备对总线有无控制功能分为：

  - 主设备：获得总线控制权的设备

  - 从设备：被主设备访问的设备，只能响应从主设备发来的总线命令

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605211430240.png" alt="image-20220605211430240" style="zoom:67%;" />

### 集中仲裁方式

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605211246661.png" alt="image-20220605211246661" style="zoom: 50%;" />

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605211523334.png" alt="image-20220605211523334" style="zoom:67%;" />

#### 链式查询方式

- 分为3根线：BG（总线**允许**）、BR（总线**请求**）、BS（总线**忙**）
- 优先级：离总线控制器越近，优先级越高；优先级固定
- BS 总线忙的信号建立者：是获得总线控制权的设备建立的

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605211648721.png" alt="image-20220605211648721" style="zoom:67%;" />

#### 计数器查询方式

- 2根线（BR、BS）+ 一组设备地址线

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605211914092.png" alt="image-20220605211914092" style="zoom:67%;" />

#### 独立请求方式

- 每一个设备，一对BG、BR，所有设备共用一个BDS，总线控制部件中的**排队器**

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605211952501.png" alt="image-20220605211952501" style="zoom:67%;" />

### 分布仲裁方式

仲裁器、仲裁总线

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605212022248.png" alt="image-20220605212022248" style="zoom:67%;" />



## 总线的操作和定时

- 占用总线的一对设备如何进行数据传输

**总线周期的阶段**：

- **申请分配阶段：**主设备提出申请、**总线仲裁机构决定将总线的使用权授予某一主设备**
- **寻址阶段：**主设备发出从设备的地址和有关命令
- **传输阶段：**进行数据传输
- **结束阶段：**主模块的有关信号从系统总线撤出

**总线定时**

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605213001058.png" alt="image-20220605213001058" style="zoom:67%;" />

**上升沿、下降沿**

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605213142106.png" alt="image-20220605213142106" style="zoom:67%;" />

### 同步通信（同步定时方式）

- 统一的时钟信号，时钟产生相等的时间间隔，每个间隔一个总线周期，一个总线周期中发送和接受方可一次数据传送。
- **先传送地址，再传送数据**

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605213207689.png" alt="image-20220605213207689" style="zoom:67%;" />

- 一个总线传输周期中的时钟周期⭐
  - T1：主模块发出**地址**
  - T2：主模块发出**命令**
  - T3：从模块提供**数据**
  - T4：主模块**撤销读命令**、从模块**撤销数据**

- 地址信号保持一个总线周期⭐
  - 因为**总线是分时共享**的，为了确保在该总线周期内该地址端口对应的输入设备将数据稳定正确地写入CPU中。
- 读命令在地址信号出现后才能出现在总线上
  - 先送地址是为了**进行地址译码找到外设**，然后再发送读控制命令，控制该外设的读写。
  - 如果顺序颠倒，则会出现读写错误，即：**有可能将其他外设端口的数据读进来**。 

- 读写的区别（读改为写）
  - 需要改变**读写控制信号**，读命令切换为写命令。
  - 数字总线上的数据会更早的出现在总线上**。因为数据由 CPU 提供，无需更多的准备时间。** 

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607135032771.png" alt="image-20220607135032771" style="zoom:80%;" />



### 异步通信（异步定时方式）

- 没有统一的时钟和相等的时间间隔；**握手信号（应答信号：控制总线传输）**；请求、回答
- **一个总线周期内无法完成传输过程，采用异步方式、或者半同步方式⭐**

- 根据请求和回答信号的撤销是否互锁，分为：

  - 不互锁：速度最快 可靠性最差

  - 半互锁

  - 全互锁：速度最慢 可靠性最好

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605213940923.png" alt="image-20220605213940923" style="zoom: 33%;" />

- 异步通信优缺点：

  - 优点：总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合

  - 缺点：比同步控制复杂，速度慢


- **波特率**、**比特率**

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605213307650.png" alt="image-20220605213307650" style="zoom:50%;" />



### 半同步通信

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605213432044.png" alt="image-20220605213432044" style="zoom:50%;" />

- 同步周期中本该是发送数据的周期，设置一个WAIT等待响应信号，若没有收到数据，则延长等待周期。
- **应答信号（握手信号）的采样仍然由同步时钟控制**



### ⭐同步、半同步的区别

- 同步
  - 发送方用系统时钟前沿发信号。接收方用系统时钟后沿判断、识别。
- 异步
  - 允许不同速度的模块和谐工作。
- 半同步通信
  - 统一时钟的基础上，增加一个等待响应信号。



### 分离式通信

- 利用从模块准备数据这段总线空闲的时间
- 在设备准备阶段为其他设备服务，提高总线利用率。

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605213453933.png" alt="image-20220605213453933" style="zoom:67%;" />



## 总线标准

系统总线标准、设备总线标准、局部总线标准

- 即插即用
- 热插拔

#### 系统总线：ISA、EISA

##### 局部总线标准：PCI

PCI是独立于CPU的局部总线：高速外设与CPU--三总线结构中

- 主存总线（CPU与主存）、DMA（高速外设与主存）、I/O总线（CPU与外设）

##### 局部总线标准：AGP

##### 局部总线标准：PCI-E

##### 局部总线标准：VESA

- 针对高速传输多媒体图像

#### 设备总线

##### 设备总线：USB

- 串行
- 一种连接外部设备的I/O总线标准，属于设备总线。

##### 设备总线：RS-232C

- 串行通信总线

##### 设备总线：IDE（ATA）

- 硬盘光驱接口
- 并行

##### 设备总线：SATA

- 串行



# 7 I/O系统



## I/O总线

- 数据线
  - 传输如数据缓冲器寄存器、状态寄存器的内容
- 地址线
  - 传送与CPU交换数据的端口地址                
- 控制线
  - 用以给I/O端口发送读写信号，对端口进行读写控制。



## 基本概念

### I/O系统演变过程

- 早期：分散连接，CPU与I/O串行工作，CPU通过程序不断查询I/O设备是否做好准备（**程序查询方式**）

- 接口模块和DMA阶段：总线连接，CPU与I/O并行工作
  I/O向CPU发出中断请求、DMA总线--主存和I/O设备交换信息（**程序中断方式**）（**DMA方式**）
  
- I/O通道：使用通道指令（**通道方式**）

- I/O处理机

  

### 基本组成

- I/O软件
  - I/O指令（CPU指令的一部分）：操作码+命令码+设备码
  - 通道指令（通道自身的指令）：如果有通道，则I/O指令只需控制I/O设备的打开和关闭；否则需在命令码中指明具体执行的操作
  
- I/O硬件

  

### I/O方式

程序查询方式、程序中断方式：程序控制，用于速度较低的外设

DMA方式、通道方式：硬件控制，用于速度较高的外设

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606222422279.png" alt="image-20220606222422279" style="zoom:80%;" />

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606222526883.png" alt="image-20220606222526883" style="zoom:80%;" />

## 外部设备

- 输入设备：鼠标、键盘

- 输出设备：显示器、打印机

  - 显示器分类

    - 阴极射线管CRT显示器

      按显示信息内容不同：

      - 字符 / 图形 / 图像显示器
        - 如果是字符显示器，计算VRAM容量 = 一个屏幕可显示的字符数目 × ASCII码的长度
          因为VRAM显存中存的是ASCII码

      按扫描方式不同：

      - 光栅扫描显示器
  - 随机扫描显示器
    
    - 液晶显示器LCD

    - 发光二极管LED显示器

  - 显示器的参数：

    - 屏幕大小（对角线长度）
  - **分辨率**
    - **灰度级**
  - **刷新 刷新频率（帧频）**
    - **显示存储器VRAM（显存）**
  
  - 显存容量的计算
  
    **VRAM容量 = 分辨率 × 灰度级位数**

    VRAM带宽 = 分辨率 × 灰度级位数 × 帧频

  - 打印机

- 外存设备：除计算机内存、CPU缓存之外的存储器；硬磁盘、光盘

### 外存储器

- 磁表面存储器
- <img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606165018063.png" alt="image-20220606165018063" style="zoom:80%;" />

##### 磁盘存储器⭐

- ###### 磁盘的组成

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606164852827.png" alt="image-20220606164852827" style="zoom:80%;" />

- 磁盘读写最小单位：扇区


- 存储数据的区域：磁头数、柱面数、扇区数


> 磁道：就是一个个圆环

- 硬盘存储器组成：磁盘存储器、磁盘控制器、盘片


###### 磁盘的性能指标

- **磁盘容量**：一个磁盘所能存储的总字节数

  - 格式化容量：小于非格式化容量，按照某种记录格式所能存储信息的总量，由于格式 所以对面积利用可能不充分
  - 非格式化容量：磁记录表面可以利用的磁化单元总数

- 记录密度：盘片单位面积上记录的二进制信息量

  - **道密度**：沿半径方向单位长度上的**磁道数**  道/cm

  - **位密度**：磁道单位长度上所能记录的**二进制位数**  bit/cm

    > 磁道记录的信息量一定，所以不是磁道的圆环越大记录的信息量越多
    > 每个磁道的位密度都不同
    > 内圈短，位密度大；外圈，位密度小——题目说明位密度，判断是内圈还是外圈

  - 面密度：道密度 × 位密度

- **⭐平均存取时间**：寻道时间（磁头移动到目的**磁道**）+ 旋转延迟时间（磁盘旋转，使磁头定位到**扇区**）+ 传输时间（传输数据 读或写扇区的时间）/* 可能还有磁盘控制器启动的延迟时间 */

  > 寻道时间、旋转延迟时间若无特殊声明，则用平均时间；如旋转延迟时间的average=转一圈的时间的一半

- **数据传输率**：磁盘存储器在单位时间内向主机传送数据的**字节数** = 每秒的转数 × 每条磁道容量N个字节

-  磁盘的转速提高一倍只是提高了在选中磁道上的旋转等待时间，而平均存取时间包括两部分，即平均寻道时间加上选中磁道上的旋转等待时间。因此，“平均存取时间减半”的说法是错误的。**平均寻道时间（磁头移动到目的磁道的时间）与磁盘的转速没有什么关系**。

  

###### 磁盘地址

驱动器号 + 柱面号（磁道号）+ 盘面号 + 扇区号

###### 硬盘工作过程

寻址、读盘、写盘

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606165000354.png" alt="image-20220606165000354" style="zoom:67%;" />

###### 磁盘阵列

- 原理：磁盘便宜

- RAID0：提高传输率 交叉并行

  RAID1：使用镜像 提高可靠性

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220606165105820.png" alt="image-20220606165105820" style="zoom:67%;" />



##### 光盘存储器

组成：

- 光盘片、光盘驱动器、光盘控制器、光盘驱动软件

类型：

- CD-ROM：只读
- CD-R：可写一次
- CD-RW：可重复读写
- DVD-ROM：高容量

##### 固态硬盘

- 固态硬盘和U盘都是基于闪存Flash Memory，但U盘芯片较少容易出问题

  

## I/O接口

- 又称I/O控制器，设备控制器，主要协调主机与外部设备之间的数据传输。

- 接口的功能：
  ①设备选址——设备选择电路 
  ②传送命令——命令寄存器、命令译码器
  ③传送数据——**数据缓冲**寄存器DBR（格式转换）
  ④**反应I/O设备的工作状态**
- 内部接口：数据线、地址线、命令线、状态线
- 外部接口

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605215048914.png" alt="image-20220605215048914" style="zoom:67%;" />

输入操作举例：

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605215113040.png" alt="image-20220605215113040" style="zoom:67%;" />

### 接口与端口

- I/O端口：**接口电路中可直接被CPU访问的寄存器**
  - 数据端口：读写
  - 控制端口：写
  - 状态端口：读
- I/O端口想要被CPU访问，必须要有端口地址，每一个端口对应一个端口地址



#### 端口地址编制方案

- 统一编址**（存储器映射方式）**
  - 把I/O端口当作存储器的单元进行地址分配，用**统一的访存指令**就可以访问端口。
  - 进行输入输出的指令是**访存指令**
    - 访问端口，进行输入输出操作，所以是访存指令

- 独立编址
  - 有单独的I/O总线时
  - 独立编址CPU需要专门的输入/输出指令访问端口。
  - 靠不同的指令区分内存和I/O设备


<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605215229257.png" alt="image-20220605215229257" style="zoom:67%;" />

### I/O接口的类型

- 按数据传送方式分

  - 并行接口：一个字节或一个字的所有位同时发送

  - 串行接口：一位位传送

    > 此处串并行指的是外设和接口一侧的传送方式，主机和接口一侧一定是并行传送
    > 所以接口要实现数据格式转换

- **按主机访问I/O设备的控制方式**

  - 程序查询接口
  - 中断接口
  - **DMA接口**

- 按功能选择的灵活性

  - 可编程接口
  - 不可编程接口





## 中断系统

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605220016466.png" alt="image-20220605220016466" style="zoom:67%;" />

**中断概念**

- 异常情况或特殊请求，CPU暂时终止现行程序进行处理，处理后返回断电

**中断工作流程**⭐：

- **中断请求**

- **中断响应**
  多个中断时 中断判优（中断判优逻辑）
  
- **中断处理**
  
  - **中断隐指令（硬件）**
  
    - 关中断
      - IF=0表示关中断（不允许中断）
    - 保存断点
    - 引出中断服务程序
  
  - **中断服务程序**
  
    - 中断识别
  
    - 保存现场
  
    - 中断事务处理
  
    - 恢复现场
  
    - 开中断
  
    - 中断返回
  
      

#### 程序中断的作用

- 实现CPU与I/O设备的并行工作

- 处理硬件故障和软件错误

- 实现人机交互，用户干预机器

- 实现多道程序、分时操作

- 实时处理需借助中断系统来快速响应

- 实现应用程序和操作系统的切换（软中断）

- 多处理系统中各处理器之间的信息交换和任务切换

  

### 中断请求

#### 中断请求的分类

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605220908590.png" alt="image-20220605220908590" style="zoom: 67%;" />

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605220959781.png" alt="image-20220605220959781" style="zoom:67%;" />

- 外中断

- 内中断：陷阱、陷入、故障、终止

  

#### 中断请求标记

> 内中断请求在执行指令时可顺便查询**INTR**，外中断请求则需要在特定时间查询
> 统一时刻为每条指令执行阶段结束前
> 但若指令很长，则设置查询断点

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605221027805.png" alt="image-20220605221027805" style="zoom:67%;" />



### 中断响应：中断判优

- ⭐CPU响应I/O中断请求的条件和时间（上面的图）
  - 条件
    - CPU允许中断，允许中断触发器为1
    - 中断源有中断请求
    - 中断请求且未被屏蔽，经过排队后被选中
  - 时间
    - **每条指令执行阶段的结束时刻**
    - CPU发出中断查询信号，对中断请求信号进行获取

- 硬件排队器 / 查询程序
- 允许**中断触发器置1/0（**每个中断源的接口电路中都有一个“中断触发器”，用于保存中断源向CPU的中断请求信号**）**是由硬件自动完成的。

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605221053743.png" alt="image-20220605221053743" style="zoom:67%;" />

优先级：

- 硬件故障中断为最高级；其次是软件中断
- 非屏蔽优先于可屏蔽中断
- DMA**（控制高速设备）**请求优于I/O设备的中断请求
- 高速设备优先于低速设备
- 输入设备优先于输出设备
- 实时设备优先于普通设备



### 中断处理

CPU占用情况 = 中断隐指令 + 中断服务程序

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605221136992.png" alt="image-20220605221136992" style="zoom:67%;" />

> 关中断和保存断点一般几乎同时完成，因为这两步由硬件实现，硬件工作的特点是并行



##### 中断隐指令（中断响应）

- **关中断**
  - 在中断服务程序中，为保护中断现场（即CPU中寄存器的内容）期间不被新的中断打扰，必须关中断

- **保存断点**
  - 保存原来程序的断点（程序计数器PC的内容），存入堆栈或指定单元**——中断隐指令完成**

- **引出中断服务程序（送中断向量）**
  - 将中断服务程序的入口地址传给PC
  - 软件查询法
  - 硬件向量法：将不同中断的入口服务地址存入一段主存——向量地址
    **排队器**输出中断请求信号给**中断向量地址形成部件**，输出向量地址或中断类型号，再由**向量地址**中的内容对应找到**入口地址**




##### 中断服务程序⭐

- **保护现场：**
  - 使用堆栈或特定存储单元
  - **保存通用寄存器和状态寄存器的内容**——中断服务程序完成

- **中断服务**：程序执行的主体部分
- **恢复现场：**POP出栈指令 / 取数指令，送回寄存器
- **开中断**
- **中断返回：**中断返回指令回到断点处



⭐⭐⭐

**单重中断**

- 执行中断服务程序时不响应新的中断请求

**多重中断**

- 中断嵌套，执行中断服务程序时可响应新的中断请求
- **在中断服务程序完成现场保护后会开中断，方便中断嵌套。**
- CPU一般在一条指令执行结束的阶段采样中断请求信号，查看是否存在中断请求，决定是否响应。
- ⭐采用屏蔽技术后，该服务程序要补充**增加屏蔽字**和**恢复屏蔽字**两部分

**异同点**

- 二者**都可以有多个中断源**。
- 但单级中断的中断服务程序不可被其他中断源再次中断，***所以中断服务程序全程为关中断状态；***
- 多重中断的中断服务程序，保护现场的内容包括中断屏蔽字，并且***保护现场后立即开中断***，方便中断嵌套。

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605221512192.png" alt="image-20220605221512192" style="zoom:67%;" />

- 上图的执行过程：

- 单重中断：
  - 中断隐指令
    - 关中断→保存断点→送中断向量
  - 中断服务执行程序
    - 保护现场→执行中断服务程序→恢复现场→开中断→中断返回
- 多重中断**(采用屏蔽技术)**
  - 中断隐指令
    - 关中断→保存断点→**送中断向量（将不同中断的入口服务地址存入一段主存——向量地址）**
  - 中断服务执行程序
    - 保护现场**和屏蔽字**→开中断→执行中断服务程序→关中断→恢复现场**和屏蔽字**→开中断→中断返回



###### 中断屏蔽技术

- ⭐每个中断请求触发器INTP都有一个屏蔽触发器MASK，将所有屏蔽触发器组合结合在一起，就构成了**屏蔽寄存器**。该寄存器的内容就是屏蔽字！

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220607101413376.png" alt="image-20220607101413376" style="zoom:80%;" />

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605221557795.png" alt="image-20220605221557795" style="zoom: 80%;" />



**屏蔽字寄存器中的内容：**某位屏蔽字是1 则中断响应。0 不会被响应（原理见上图）

屏蔽字设置规律：（一个中断是否能屏蔽另一个中断）

- **一般 1 表示屏蔽， 0 表示正常申请**

- 每个中断源对应一个屏蔽字（在屏蔽寄存器中）

- 屏蔽字中 1 越多，优先级越高 

- 每个屏蔽字至少要有一个 1 （至少要能屏蔽自身的中断）

  

###### 例题：求中断屏蔽字、画出CPU执行轨迹

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605221645770.png" alt="image-20220605221645770" style="zoom:67%;" />



## IO方式

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605222550620.png" alt="image-20220605222550620" style="zoom: 33%;" />

## ①程序查询方式

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605222403427.png" alt="image-20220605222403427" style="zoom:67%;" />

CPU执行以下流程：

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605222443807.png" alt="image-20220605222443807" style="zoom:67%;" />

- 传送数据一般为一个字的原因
  - 外设数据→数据线→DBR→数据线→CPU中的寄存器，外设中的数据即使是要放到主存中，也必须先放进CPU的寄存器中
    - 受寄存器的限制 只能传送寄存器的位数一般是一个字

  - **主机与设备串行工作**


程序查询方式接口的结构：

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605222639282.png" alt="image-20220605222639282" style="zoom:67%;" />



#### 例题：程序查询方式

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605222659243.png" alt="image-20220605222659243" style="zoom:67%;" />

## ②程序中断方式

- **CPU 与设备并行工作**
- **传送与主程序串行工作**

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605222904030.png" alt="image-20220605222904030" style="zoom:67%;" />

### 例题

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605222927318.png" alt="image-20220605222927318" style="zoom:80%;" />



## ③DMA方式

- ⭐**让主存和I/O外设之间直接通信**
- 在主存与外设之间增加数据总线

![image-20220605223005082](C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605223005082.png)

- 程序中断方式中 **只要I/O需要数据传送 就要中断响应**，不适用于高速外设传输局
- CPU的事
  - 预处理时CPU完成寄存器初值设置等准备工作
  - 后处理时CPU执行中断服务程序做DMA结束处理。
  - 


<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605223027801.png" alt="image-20220605223027801" style="zoom:67%;" />

> 首先外设通过DMA总线把数据写入DMA中的数据缓冲器，写满后发出中断请求，CPU给出相应信息（如写入主存单元的地址和长度）后，CPU继续工作，DMA进行数据传送到主存、再写满数据缓冲寄存器

DMA控制器功能：

- 传送前：
  - 接受外设发出的DMA请求，向CPU发送总线请求
  - CPU响应该总线请求，发出总线响应信号，**DMA接管总线控制权**，进入DMA操作期
- 传送时：
  - 确定传送数据的主存单元地址及长度，并能自动修改主存地址计数和传送长度计数
  - 规定数据在主存和外设间的传送方向，发出读写控制信号，执行数据传送操作
- 传送后：向CPU报告DMA操作结束

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605223117776.png" alt="image-20220605223117776" style="zoom:67%;" />

DMA方式的特点：

- 由于不需要经过CPU，因此不必中断先行程序，**I/O与主机并行工作**。

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605223138968.png" alt="image-20220605223138968" style="zoom: 80%;" />

### DMA传送过程

DMA向主存的数据传送阶段：

- DMA中的主存起始地址（CPU给出的）送总线
- 数据送主存
- 修改主存地址
- 修改字计数器

数据块传送结束，向CPU发送中断请求

- **外设**采用 DMA 方式**与主存通信**时，通过 DMA 接口与 CPU 进行联络的握手信号 
  - **HRQ**（DMA控制器向总线发送总线请求）Hold Request
  - **HLDA** （CPU将总线控制权交给DMA控制器） Hold Acknowledgment 总线响应
  - **DREQ**（DMA Request）DMA请求
  - **DACK**（DMA Acknowledgment） DMA响应

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605223221353.png" alt="image-20220605223221353" style="zoom:80%;" />



### DMA传送方式

数据传送阶段，DMA和CPU可能存在访存冲突，解决：

- **停止CPU的访问主存**

- **DMA**与CPU交替访存

- **周期挪用**（周期窃取）

  DMA访存的可能情况：

  - CPU此时不访存：不冲突
  - CPU正在访存：CPU的该存储周期结束后让出总线
  - CPU与DMA同时请求访存：I/O设备访存优先

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605223246405.png" alt="image-20220605223246405" style="zoom:80%;" />

### DMA方式与中断方式

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605223311548.png" alt="image-20220605223311548" style="zoom:80%;" />

- 中断方式请求的是CPU处理时间，DMA请求的是总线的使用权
- DMA获得内存总线的控制权，单纯的是为了做内存访问，所以仅**=**。
- 中断响应发生在一条指令执行结束后，DMA响应发生在一个总线事务完成后

#### 例题：CPU占用情况

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605223338132.png" alt="image-20220605223338132" style="zoom:80%;" />

<img src="C:\Users\icebear\AppData\Roaming\Typora\typora-user-images\image-20220605223356988.png" alt="image-20220605223356988" style="zoom:80%;" />

